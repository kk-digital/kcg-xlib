// Copyright Â© Clinton Ingram and Contributors.  Licensed under the MIT License.

//------------------------------------------------------------------------------
//	<auto-generated>
//		This code was generated from a template.
//		Manual changes will be overwritten if the code is regenerated.
//	</auto-generated>
//------------------------------------------------------------------------------

namespace Blake2Fast.Implementation;

unsafe partial struct Blake<#= alg.suffix #>HashState
{
	private static void mixScalar(<#= alg.wtype #>* sh, <#= alg.wtype #>* m<#= alg == b3 ? $", {alg.wtype}* o, bool truncate" : "" #>)
	{
<#
for (int i = 0; i < 16; i++) {
#>
		<#= alg.wtype #> m<#=$"{i:d2}"#> = m[<#=$"{i:d2}"#>];
<#
}

WriteLine(null);
mixvars (alg, new[] { 0, 1, 2, 3, 4, 5, 6, 7 });
WriteLine(null);
mixvars (alg, alg == b3 ? new[] { 8, 9, 10, 11 } : new[] { 8, 9, 10, 11, 12, 13, 14, 15 });
if (alg == b3) {
#>
		uint v12 = sh[8];  // tlo
		uint v13 = sh[9];  // thi
		uint v14 = sh[10]; // c
		uint v15 = sh[11]; // f
<#
} else {
#>

		v12 ^= sh[8];  // t[0]
		v13 ^= sh[9];  // t[1]
		v14 ^= sh[10]; // f[0]
<#
}
WriteLine(null);
for (int i = 0; i < alg.rounds; i++) {
	int s = i % 10;
	WriteLine($"\t\t//ROUND {i+1}");
	mix(alg, 0, 4,  8, 12, alg.sigma[s][ 0], 1);
	mix(alg, 1, 5,  9, 13, alg.sigma[s][ 2], 1);
	mix(alg, 2, 6, 10, 14, alg.sigma[s][ 4], 1);
	mix(alg, 3, 7, 11, 15, alg.sigma[s][ 6], 1);

	mix(alg, 2, 6, 10, 14, alg.sigma[s][ 5], 2);
	mix(alg, 3, 7, 11, 15, alg.sigma[s][ 7], 2);
	mix(alg, 0, 4,  8, 12, alg.sigma[s][ 1], 2);
	mix(alg, 1, 5,  9, 13, alg.sigma[s][ 3], 2);

	mix(alg, 0, 5, 10, 15, alg.sigma[s][ 8], 1);
	mix(alg, 1, 6, 11, 12, alg.sigma[s][10], 1);
	mix(alg, 2, 7,  8, 13, alg.sigma[s][12], 1);
	mix(alg, 3, 4,  9, 14, alg.sigma[s][14], 1);

	mix(alg, 2, 7,  8, 13, alg.sigma[s][13], 2);
	mix(alg, 3, 4,  9, 14, alg.sigma[s][15], 2);
	mix(alg, 0, 5, 10, 15, alg.sigma[s][ 9], 2);
	mix(alg, 1, 6, 11, 12, alg.sigma[s][11], 2);
}

for (int i = 0; i < 8; i++) {
#>
		<#= alg == b3 ? "o" : "sh" #>[<#=i#>] <#= alg == b3 ? "=" : "^=" #> v<#=$"{i:d2}"#> ^ v<#=$"{i+8:d2}"#>;
<#
}
if (alg == b3) {
#>

		if (!truncate)
		{
<#
	for (int i = 0; i < 8; i++) {
#>
			o[<#=$"{i+8,2}"#>] = v<#=$"{i+8:d2}"#> ^ sh[<#=i#>];
<#
	}
#>
		}
<#
}
#>
	}
}
<#+

string ror(balg alg, string x, int y) => $"({x} >> {y,2}) ^ ({x} << {(alg.bits - y),2})";

void mixvars(balg alg, int[] pos)
{
	foreach (int j in pos) {
#>
		<#= alg.wtype #> v<#=$"{j:d2}"#> = <#= j < 8 ? $"sh[{j}]" : string.Format(alg.ivfmt, alg.iv[j-8]) #>;
<#+
	}
}

void mix(balg alg, int a, int b, int c, int d, int s, int p)
{
	string sa = a.ToString("d2");
	string sb = b.ToString("d2");
	string sc = c.ToString("d2");
	string sd = d.ToString("d2");
	string ss = s.ToString("d2");
#>
		v<#=sa#> += m<#=ss#>;
		v<#=sa#> += v<#=sb#>;
		v<#=sd#> ^= v<#=sa#>;
		v<#=sd#> = <#=ror(alg, string.Concat("v", sd), p == 1 ? (alg.bits / 2) : (alg.bits / 4))#>;
		v<#=sc#> += v<#=sd#>;
		v<#=sb#> ^= v<#=sc#>;
		v<#=sb#> = <#=ror(alg, string.Concat("v", sb), p == 1 ? (alg.bits / 8 * 3) : (alg.bits == 64 ? 63 : 7))#>;

<#+
}
#>